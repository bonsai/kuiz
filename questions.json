[
  {
    "id": 1,
    "category": "コンピュータ構成",
    "question": "CPUの演算装置（ALU）が直接扱うデータを一時的に保持する記憶装置はどれか？",
    "options": ["キャッシュメモリ", "レジスタ", "主記憶装置", "補助記憶装置"],
    "answer": 2,
    "explanation": "レジスタはCPU内部にある最も高速な記憶装置で、演算中のデータや命令を一時的に保持します。"
  },
  {
    "id": 2,
    "category": "データ構造",
    "question": "スタック（Stack）の操作として正しいものはどれか？",
    "options": ["FIFO（先入れ先出し）", "LIFO（後入れ先出し）", "ランダムアクセス", "優先度順アクセス"],
    "answer": 2,
    "explanation": "スタックはLIFO（Last In, First Out）構造で、最後に追加した要素が最初に取り出されます。PushとPopの操作があります。"
  },
  {
    "id": 3,
    "category": "ネットワーク",
    "question": "IPアドレス 192.168.1.0/24 のサブネットマスクはどれか？",
    "options": ["255.0.0.0", "255.255.0.0", "255.255.255.0", "255.255.255.128"],
    "answer": 3,
    "explanation": "/24はCIDR表記で、先頭から24ビットがネットワーク部です。これは255.255.255.0に相当します。"
  },
  {
    "id": 4,
    "category": "アルゴリズム",
    "question": "バブルソートの最悪時間計算量はどれか？",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "answer": 3,
    "explanation": "バブルソートは隣接要素を比較・交換する単純なアルゴリズムです。最悪・平均ともにO(n²)の時間計算量になります。"
  },
  {
    "id": 5,
    "category": "データベース",
    "question": "関係データベースで、候補キーの中から代表として選ばれたキーを何というか？",
    "options": ["外部キー", "主キー", "代替キー", "複合キー"],
    "answer": 2,
    "explanation": "主キー（Primary Key）は候補キーの中から選ばれた代表キーで、各行を唯一に識別します。NULLは許可されません。"
  },
  {
    "id": 6,
    "category": "セキュリティ",
    "question": "公開鍵暗号方式において、暗号化に使用するキーはどれか？",
    "options": ["送信者の秘密鍵", "送信者の公開鍵", "受信者の秘密鍵", "受信者の公開鍵"],
    "answer": 4,
    "explanation": "公開鍵暗号方式では、受信者の公開鍵で暗号化し、受信者の秘密鍵で復号します。公開鍵は誰でも入手できます。"
  },
  {
    "id": 7,
    "category": "OS",
    "question": "デッドロックが発生する条件として誤っているものはどれか？",
    "options": ["相互排除", "占有と待機", "プリエンプション可能", "循環待機"],
    "answer": 3,
    "explanation": "デッドロック発生の4条件は「相互排除」「占有と待機」「非プリエンプション」「循環待機」です。プリエンプション可能は防止策です。"
  },
  {
    "id": 8,
    "category": "ソフトウェア開発",
    "question": "ウォーターフォールモデルで、要件定義の次に行うフェーズはどれか？",
    "options": ["実装", "テスト", "設計", "運用"],
    "answer": 3,
    "explanation": "ウォーターフォールモデルの順序は「要件定義 → 設計 → 実装 → テスト → 運用」です。"
  },
  {
    "id": 9,
    "category": "コンピュータ構成",
    "question": "2進数の 1010 を10進数に変換するとどれか？",
    "options": ["8", "10", "12", "16"],
    "answer": 2,
    "explanation": "1010₂ = 1×2³ + 0×2² + 1×2¹ + 0×2⁰ = 10₁₀ です。"
  },
  {
    "id": 10,
    "category": "ネットワーク",
    "question": "OSI参照モデルでHTTPが属する層はどれか？",
    "options": ["トランスポート層", "セッション層", "プレゼンテーション層", "アプリケーション層"],
    "answer": 4,
    "explanation": "HTTPはOSI参照モデルの第7層（アプリケーション層）に属します。"
  },
  {
    "id": 11,
    "category": "コンピュータ構成",
    "question": "命令を一つずつ順に実行する方式を何というか？",
    "options": ["パイプライン処理", "逐次処理", "並列処理", "割込み処理"],
    "answer": 2,
    "explanation": "逐次処理は命令を一つずつ順番に実行する方式です。"
  },
  {
    "id": 12,
    "category": "コンピュータ構成",
    "question": "キャッシュメモリの主な目的はどれか？",
    "options": ["記憶容量の拡大", "入出力装置の制御", "アクセス速度の向上", "電源断対策"],
    "answer": 3,
    "explanation": "高速なキャッシュにデータを保持することで主記憶アクセスを減らし、全体の性能を向上させます。"
  },
  {
    "id": 13,
    "category": "データ構造",
    "question": "キュー（Queue）の特徴として正しいものはどれか？",
    "options": ["LIFO構造", "FIFO構造", "ランダムアクセス構造", "木構造"],
    "answer": 2,
    "explanation": "キューは先入れ先出し（FIFO）のデータ構造です。"
  },
  {
    "id": 14,
    "category": "データ構造",
    "question": "二分探索木で探索時間を短くするために重要な条件はどれか？",
    "options": ["高さが小さいこと", "ノード数が多いこと", "葉の数が奇数であること", "根が0であること"],
    "answer": 1,
    "explanation": "木の高さが小さいほど、探索に必要な比較回数が少なくなります。"
  },
  {
    "id": 15,
    "category": "アルゴリズム",
    "question": "線形探索と比較したとき、二分探索が有効となる前提条件はどれか？",
    "options": ["データがランダムに並んでいる", "データがソートされている", "データが少ない", "データが文字列である"],
    "answer": 2,
    "explanation": "二分探索は配列が昇順などにソートされていることが前提です。"
  },
  {
    "id": 16,
    "category": "アルゴリズム",
    "question": "クイックソートの平均時間計算量はどれか？",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "answer": 2,
    "explanation": "クイックソートの平均計算量はO(n log n)ですが、最悪の場合はO(n²)です。"
  },
  {
    "id": 17,
    "category": "ネットワーク",
    "question": "TCPの特徴として適切なものはどれか？",
    "options": ["コネクションレス型", "ベストエフォート型", "コネクション型で信頼性が高い", "ブロードキャスト専用"],
    "answer": 3,
    "explanation": "TCPはコネクション型で、再送制御などにより信頼性の高い通信を提供します。"
  },
  {
    "id": 18,
    "category": "ネットワーク",
    "question": "DNSの主な役割はどれか？",
    "options": ["IPアドレスの暗号化", "IPアドレスとドメイン名の対応付け", "メールの配送制御", "パケットの順序制御"],
    "answer": 2,
    "explanation": "DNSはドメイン名とIPアドレスを相互に変換する仕組みです。"
  },
  {
    "id": 19,
    "category": "データベース",
    "question": "トランザクションの性質ACIDのうち、Iに該当するものはどれか？",
    "options": ["原子性", "一貫性", "独立性（隔離性）", "永続性"],
    "answer": 3,
    "explanation": "I（Isolation）は他トランザクションからの独立性（隔離性）を指します。"
  },
  {
    "id": 20,
    "category": "データベース",
    "question": "正規化の目的として最も適切なものはどれか？",
    "options": ["アクセス速度の向上", "データの冗長性排除と整合性向上", "ディスク容量の増加", "インデックス数の削減"],
    "answer": 2,
    "explanation": "正規化は冗長性を減らし、更新時の不整合を防ぐことが目的です。"
  },
  {
    "id": 21,
    "category": "セキュリティ",
    "question": "SQLインジェクション攻撃を防ぐ方法として適切なものはどれか？",
    "options": ["パスワードのハッシュ化", "ファイアウォールの設置", "プレースホルダによるパラメータ化", "暗号化通信の利用"],
    "answer": 3,
    "explanation": "プレースホルダを用いたパラメータ化クエリにより、SQL文への不正な文字列埋め込みを防げます。"
  },
  {
    "id": 22,
    "category": "セキュリティ",
    "question": "XSS（クロスサイトスクリプティング）対策として有効なものはどれか？",
    "options": ["入力値のサニタイズとエスケープ", "パスワードの複雑化", "VPNの利用", "２要素認証の導入"],
    "answer": 1,
    "explanation": "ブラウザに出力する前にHTMLエスケープすることで、スクリプトの実行を防ぎます。"
  },
  {
    "id": 23,
    "category": "OS",
    "question": "プリエンプティブなスケジューリング方式の説明として適切なものはどれか？",
    "options": ["プロセスが自発的にCPUを解放する方式", "OSが強制的にCPUを奪う方式", "一度割り当てたCPUを最後まで占有する方式", "バックグラウンドだけを対象とする方式"],
    "answer": 2,
    "explanation": "プリエンプティブではタイムスライスなどによりOSがCPUを強制的に切り替えます。"
  },
  {
    "id": 24,
    "category": "OS",
    "question": "仮想記憶方式で使われるページングの説明として適切なものはどれか？",
    "options": ["プログラムを手動で分割する方式", "主記憶を固定長ブロックに分割する方式", "CPUレジスタを増やす方式", "キャッシュの階層を増やす方式"],
    "answer": 2,
    "explanation": "ページングでは主記憶をページと呼ばれる固定長ブロックに分割し、仮想アドレスと対応付けます。"
  },
  {
    "id": 25,
    "category": "ソフトウェア開発",
    "question": "アジャイル開発の特徴として最も適切なものはどれか？",
    "options": ["文書重視で工程を厳密に分ける", "短いイテレーションで継続的にリリースする", "仕様凍結後は変更を受け付けない", "ウォーターフォールよりテスト工程が少ない"],
    "answer": 2,
    "explanation": "アジャイル開発では短い反復と頻繁なリリース・フィードバックが特徴です。"
  },
  {
    "id": 26,
    "category": "ソフトウェア開発",
    "question": "ユニットテストの目的として最も適切なものはどれか？",
    "options": ["システム全体の性能評価", "モジュール単位の動作検証", "ユーザー受け入れの確認", "運用手順の文書化"],
    "answer": 2,
    "explanation": "ユニットテストは関数やクラスなど小さな単位の動作を確認するテストです。"
  },
  {
    "id": 27,
    "category": "コンピュータ構成",
    "question": "RISCプロセッサの特徴として適切なものはどれか？",
    "options": ["複雑な命令を少数持つ", "単純な命令を少数持つ", "複雑な命令を多数持つ", "単純な命令を多数持つ"],
    "answer": 2,
    "explanation": "RISCは単純で実行時間のそろった命令を少数用意し、パイプライン処理しやすくした設計です。"
  },
  {
    "id": 28,
    "category": "コンピュータ構成",
    "question": "フラッシュメモリの特徴として正しいものはどれか？",
    "options": ["揮発性である", "書き換え不可である", "不揮発性で書き換え可能である", "主記憶としてしか使えない"],
    "answer": 3,
    "explanation": "フラッシュメモリは電源を切っても内容が保持され、書き換えも可能な不揮発性メモリです。"
  },
  {
    "id": 29,
    "category": "データ構造",
    "question": "ハッシュ表で衝突が発生したときの解決法として線形探索を用いる方式を何というか？",
    "options": ["チェイン法", "オープンアドレス法", "平衡二分木法", "マルチマップ法"],
    "answer": 2,
    "explanation": "オープンアドレス法では空き領域が見つかるまで順に探索します。"
  },
  {
    "id": 30,
    "category": "データ構造",
    "question": "グラフ探索アルゴリズムDFSの特徴として適切なものはどれか？",
    "options": ["最も近いノードから順に広がる", "常に最短経路を見つける", "深くたどれるところまで進んでから戻る", "重み付き辺にしか使えない"],
    "answer": 3,
    "explanation": "深さ優先探索（DFS）は一つの経路を深くたどり、行き止まりで戻って別の経路を探索します。"
  },
  {
    "id": 31,
    "category": "ネットワーク",
    "question": "HTTP/2で導入された主な特徴はどれか？",
    "options": ["コネクションレス通信", "テキストベースのヘッダ", "ストリームの多重化", "UDPへの移行"],
    "answer": 3,
    "explanation": "HTTP/2では1本のTCP接続上で複数ストリームを多重化して効率的に通信します。"
  },
  {
    "id": 32,
    "category": "ネットワーク",
    "question": "LAN内でブロードキャストフレームを転送しない装置はどれか？",
    "options": ["リピータハブ", "レイヤ2スイッチ", "レイヤ3スイッチ（ルータ）", "ブリッジ"],
    "answer": 3,
    "explanation": "レイヤ3スイッチ（ルータ）はIPレイヤで経路制御し、ブロードキャストドメインを分割します。"
  },
  {
    "id": 33,
    "category": "データベース",
    "question": "インデックスを作成する主な目的として適切なものはどれか？",
    "options": ["更新処理を高速化する", "検索処理を高速化する", "データの冗長性を高める", "バックアップを容易にする"],
    "answer": 2,
    "explanation": "インデックスは検索条件に合致する行を高速に特定するための仕組みです。"
  },
  {
    "id": 34,
    "category": "データベース",
    "question": "ビューを利用する主な目的として最も適切なものはどれか？",
    "options": ["性能向上のみを目的とする", "物理設計を簡略化する", "利用者ごとに必要な論理表を提供する", "バックアップを自動化する"],
    "answer": 3,
    "explanation": "ビューは複数表を結合・抽出して利用者向けの論理表を提供し、権限制御にも使えます。"
  },
  {
    "id": 35,
    "category": "セキュリティ",
    "question": "ハッシュ関数の性質として衝突耐性を説明したものはどれか？",
    "options": ["同じ入力から同じ出力が得られる", "異なる入力から異なる出力が常に得られる", "同じ出力となる異なる入力を見つけることが困難である", "出力から入力を容易に計算できる"],
    "answer": 3,
    "explanation": "衝突耐性とは、同じハッシュ値となる別の入力を見つけることが現実的に困難である性質です。"
  },
  {
    "id": 36,
    "category": "セキュリティ",
    "question": "多要素認証における「所有要素」に分類されるものはどれか？",
    "options": ["パスワード", "指紋", "ワンタイムパスワードトークン", "顔認証"],
    "answer": 3,
    "explanation": "所有要素は利用者が所持している物理・論理的なもの（ICカードやトークンなど）です。"
  },
  {
    "id": 37,
    "category": "OS",
    "question": "スワッピングが頻繁に発生して処理性能が大幅に低下している状態を何というか？",
    "options": ["デッドロック", "スラッシング", "スタベーション", "フラグメンテーション"],
    "answer": 2,
    "explanation": "主記憶と補助記憶の入れ替えが多発しCPUが待たされる状態をスラッシングといいます。"
  },
  {
    "id": 38,
    "category": "OS",
    "question": "スプーリングの例として最も適切なものはどれか？",
    "options": ["CPUの割込み処理", "仮想記憶のページング", "印刷データを一時的にディスクに蓄える処理", "プロセス間通信"],
    "answer": 3,
    "explanation": "スプーリングは遅い装置への入出力を一時的に高速な記憶装置に蓄えてからまとめて処理する方式です。"
  },
  {
    "id": 39,
    "category": "ソフトウェア開発",
    "question": "バージョン管理システムGitにおいて、リモートリポジトリから最新の変更を取得して自分のブランチに自動マージするコマンドはどれか？",
    "options": ["git clone", "git pull", "git fetch", "git commit"],
    "answer": 2,
    "explanation": "git pullはfetchとmergeをまとめて行い、リモートの変更を現在のブランチに取り込みます。"
  },
  {
    "id": 40,
    "category": "ソフトウェア開発",
    "question": "継続的インテグレーション（CI）の目的として適切なものはどれか？",
    "options": ["リリース回数を減らす", "テストを開発の最後にまとめて行う", "変更を頻繁に統合し品質問題を早期に検出する", "開発者間の通信を減らす"],
    "answer": 3,
    "explanation": "CIではコード変更を頻繁に統合し、自動テストにより問題を早期発見します。"
  },
  {
    "id": 41,
    "category": "コンピュータ構成",
    "question": "パイプライン処理におけるハザードのうち、命令間のデータ依存によって生じるものはどれか？",
    "options": ["構造ハザード", "データハザード", "制御ハザード", "キャッシュハザード"],
    "answer": 2,
    "explanation": "先行命令の結果が確定する前に後続命令がその値を参照しようとする場合にデータハザードが発生します。"
  },
  {
    "id": 42,
    "category": "コンピュータ構成",
    "question": "冗長電源ユニットを持つサーバの目的として最も適切なものはどれか？",
    "options": ["性能向上", "可用性向上", "セキュリティ向上", "保守性向上のみ"],
    "answer": 2,
    "explanation": "電源を二重化することで片方が故障してもサービス継続でき、可用性を高めます。"
  },
  {
    "id": 43,
    "category": "データ構造",
    "question": "優先度付きキューの実装に適しているデータ構造はどれか？",
    "options": ["スタック", "単純配列", "ヒープ", "連結リスト"],
    "answer": 3,
    "explanation": "ヒープを用いると最大（最小）値の取り出しと挿入を効率的に行えます。"
  },
  {
    "id": 44,
    "category": "アルゴリズム",
    "question": "ダイクストラ法はどのような問題を解くアルゴリズムか？",
    "options": ["最小全域木問題", "最大フロー問題", "単一始点最短経路問題", "巡回セールスマン問題"],
    "answer": 3,
    "explanation": "ダイクストラ法は非負辺重みグラフにおける単一始点最短経路を求めるアルゴリズムです。"
  },
  {
    "id": 45,
    "category": "ネットワーク",
    "question": "NATの主な目的として最も適切なものはどれか？",
    "options": ["暗号化通信を提供する", "プライベートIPアドレスとグローバルIPアドレスを変換する", "ドメイン名をIPアドレスに変換する", "メールを中継する"],
    "answer": 2,
    "explanation": "NATは内部ネットワークのプライベートアドレスをグローバルアドレスに変換してインターネット接続を可能にします。"
  },
  {
    "id": 46,
    "category": "ネットワーク",
    "question": "無線LANの暗号化方式として推奨されるものはどれか？",
    "options": ["WEP", "WPA", "WPA2／WPA3", "暗号化なし"],
    "answer": 3,
    "explanation": "現在はWPA2またはWPA3が推奨され、WEPや初期のWPAは脆弱とされています。"
  },
  {
    "id": 47,
    "category": "データベース",
    "question": "分散データベースで、トランザクションの整合性を保つために用いられるプロトコルはどれか？",
    "options": ["スリーフェーズコミット", "ツーフェーズコミット", "ラウンドロビン", "キャッシュコヒーレンシ"],
    "answer": 2,
    "explanation": "ツーフェーズコミットは複数ノードにまたがるトランザクションの一貫性を保証するプロトコルです。"
  },
  {
    "id": 48,
    "category": "セキュリティ",
    "question": "情報セキュリティにおけるCIAの「A」が意味するものはどれか？",
    "options": ["真正性", "可用性", "責任追跡性", "匿名性"],
    "answer": 2,
    "explanation": "CIAのAはAvailability（可用性）であり、必要なときに情報資産を利用できることを指します。"
  },
  {
    "id": 49,
    "category": "セキュリティ",
    "question": "障害発生時にサービスを低機能で継続させる設計を何というか？",
    "options": ["フォールトトレランス", "フェイルセーフ", "フェイルソフト", "フォールトアボイダンス"],
    "answer": 3,
    "explanation": "フェイルソフトは機能を一部制限しながらもサービスを継続させる設計です。"
  },
  {
    "id": 50,
    "category": "ソフトウェア開発",
    "question": "テスト駆動開発（TDD）のサイクルとして正しい順番はどれか？",
    "options": ["テスト記述 → 実装 → リファクタリング", "実装 → テスト記述 → リファクタリング", "設計 → 実装 → テスト", "テスト → リリース → リファクタリング"],
    "answer": 1,
    "explanation": "TDDではテストを先に書き、テストを通す最小実装を行い、その後リファクタリングするサイクルを繰り返します。"
  }
]
